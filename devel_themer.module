<?php

// $form['dev_theme_log'] = array('#type' => 'checkbox',
//   '#title' => t('Display theme log'),
//   '#default_value' => variable_get('dev_theme_log', FALSE),
//   '#description' => t('Display the list of theme templates and theme functions which could have been be used for a given page. The one that was actually used is bolded.'),
// );

// devel_template_log()

function devel_themer_init() {
  if (user_access('access devel information')) {
    $path = drupal_get_path('module', 'devel_themer');
    drupal_add_css($path .'/devel_themer.css');
    drupal_add_js($path .'/devel_themer.js');
    
    if (!devel_silent()) {
      register_shutdown_function('devel_themer_shutdown');
    }
  }
}

function devel_themer_shutdown() {
  print devel_theme_log();
}

/**
 * An implementation of hook_theme_registry_alter()
 * Iterate over theme registry, injecting our catch function into every theme function.
 *
 * @return void
 **/
function devel_themer_theme_registry_alter($theme_registry) {
  foreach ($theme_registry as $hook => $data) {
    if (isset($data['function'])) {
      // For intercepting theme functions not connected to template files.
      // Copy over original registry of the hook so it can be caught later.
      $theme_registry[$hook]['devel'] = $theme_registry[$hook];
      // Replace the defaults to be intercepted.
      $theme_registry[$hook]['function'] = 'devel_catch_theme_function';
      $theme_registry[$hook]['type'] = 'module';
      $theme_registry[$hook]['theme path'] = drupal_get_path('module', 'devel_themer');
    }
  }
}

/**
 * Show all theme templates and functions that could have been used on this page.
 *
 * Not currently used.
 **/
function devel_theme_log() {
  $extension = devel_get_theme_extension();
  if (isset($GLOBALS['devel_theme_calls'])) {
    foreach ($GLOBALS['devel_theme_calls'] as $counter => $call) {
      $id = "devel_theme_log_link_$counter";
      $marker = "<div id=\"$id\" class=\"devel_theme_log_link\"></div>\n";
      
      if (count($call['candidates']) > 1) {
        $used = $call['used'];
        foreach ($call['candidates'] as $key => $value) {
          if ($call['type'] == 'template') {
            $test = $value. $extension == basename($used);
          }
          else {
            $test = $value == $used;
          }
          $call['candidates'][$key] = $test ? "<strong>$used</strong>" : $value;
        }
      }
      $name = $call['type'] == 'function' ? $call['name']. '()' : $call['name']. $extension;
      $rows[] = array($marker. $name, implode(', ', $call['candidates']));
    }
    $header = array('Template/Function', "Candidate template files or function names");
    $output = theme('table', $header, $rows);
    return $output;
  }
}

// Would be nice if theme() broke this into separate function so we don't copy logic here. this one is better - has cache
function devel_get_theme_extension() {
  global $theme_engine;
  static $extension = NULL;

  if (!$extension) {
    $extension_function = $theme_engine .'_extension';
    if (function_exists($extension_function)) {
      $extension = $extension_function();
    }
    else {
      $extension = '.tpl.php';
    }
  }
  return $extension;
}

/**
 * Log template file suggestions into a $GLOBAL.
*/
function devel_themer_preprocess($vars, $hook) {
  $counter = devel_counter();
  $GLOBALS['devel_theme_calls'][$counter] = array(
    'name' => $hook,
    'type' => 'template',
    'candidates' => $vars['template_files'],
  );
  // add in a 'template' file if it was declared
  if (isset($vars['template_file'])) {
    array_unshift($GLOBALS['devel_theme_calls'][$counter]['candidates'] = $vars['template_file']);
  }
  // add the plain template name
  array_unshift($GLOBALS['devel_theme_calls'][$counter]['candidates'], $hook);
}

// A wrapper function so we can know what template actually got called. Log that info in the GLOBAL for later display.
// I found no other easy way to determine this. Patches welcome.
function phptemplate_render_template($file, $variables) {
  $counter = devel_counter(FALSE);
  $GLOBALS['devel_theme_calls'][$counter]['used'] = $file;
  
  $output = theme_render_template($file, $variables);
  // awful attempt to get position #2 in the assoc array $variables
  $i=0;
  foreach ($variables as $key => $var) {
    if ($i == 1) {
      $name = $key;
    }
    $i++;
  }
  list($prefix, $suffix) = devel_theme_call_marker($name, $counter, 'tpl');
  // drupal_add_js(array("thmr_$counter" => array('arguments' => $variables, 'candidates' => $GLOBALS['devel_theme_calls'][$counter]['candidates'], 'used' => $GLOBALS['devel_theme_calls'][$counter]['used'])), 'setting', 'header', FALSE, FALSE, FALSE);
  return $prefix. "\n  ". $output. "\n". $suffix. "\n";
}

/**
 * Intercepts theme *functions*, adds to template log, and dispatches to original theme function.
 * This function gets injected into theme registry in devel_exit().
 */
function devel_catch_theme_function() {
  static $i=0;
  $args = func_get_args();

  // Get the function that is normally called.
  $trace = debug_backtrace();
  $candidates = $trace[2]['args'][0];
  // The node form has an array of theme functions.
  if (is_array($candidates)) {
    foreach ($candidates as $func) {
      if (function_exists($func)) {
        $call_theme_func = $func;
        break;
      }
    }
  }
  else {
    $call_theme_func = $candidates;
  }

  // Get registry for the original function data.
  $theme_registry = theme_get_registry();
  $hook_registry_data = $theme_registry[$call_theme_func]['devel'];

  // Include a file if this theme function is held elsewhere. Partial copy of theme().
  if (!empty($hook_registry_data['file'])) {
    $function_file = $hook_registry_data['file'];
    if (isset($hook_registry_data['path'])) {
      $function_file = $hook_registry_data['path'] .'/'. $function_file;
    }
    include_once($function_file);
  }
  
  $counter = devel_counter();
  $empty = TRUE;
  $output = NULL;
  $name = $hook_registry_data['function'];
  $skip = array('theme_hidden');
  
  if ($return = call_user_func_array($name, $args)) {
    $empty = FALSE;
    list($prefix, $suffix) = devel_theme_call_marker($name, $counter, 'func');
    $start_return = substr($return, 0, 31);
    $start_prefix = substr($prefix, 0, 31);

    // Pass the call to the original function. Wrap as needed.
    if ($start_return != $start_prefix && !in_array($name, $skip)) {
      $output = $prefix. "\n  ". $return. $suffix. "\n";
      // drupal_add_js(array("thmr_$counter" => array('args' => $args, 'candidates' => $candidates)), 'setting', 'header', FALSE, FALSE, FALSE);
    }
    else {
      $output = $return;
    }
  }

  // Log the call
  $GLOBALS['devel_theme_calls'][$counter] = array(
    'name' => $name,
    'type' => 'function',
    'empty' => $empty,
    'used' => $call_theme_func,
    'candidates' => is_array($trace[2]['args'][0]) ? $trace[2]['args'][0] : array($call_theme_func),
  );
  
  return $output;
}

/**
 * An implementation of hook_footer(). Emit huge js array for the benefit of the popup.
 * 
 * @return void
 **/
function devel_themer_footer() {
  drupal_add_js(array("devel_themer" => $GLOBALS['devel_theme_calls']), 'setting', 'footer', FALSE, FALSE, FALSE);
}

function devel_theme_call_marker($name, $counter, $type) {
  $id = "thmr_". $counter;
  return array("<span id=\"$id\" thmr_key=\"$name\" thmr_type=\"$type\" class=\"thmr_call\">", "</span>\n");
}

// just hand out next counter, or return current value
function devel_counter($increment = TRUE) {
  static $counter = 0;
  if ($increment) {
    $counter++;
  }
  return $counter;
}